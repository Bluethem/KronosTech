
# ImplementaciÃ³n de MÃ³dulos

## VisiÃ³n General

### Estructura del Proyecto por MÃ³dulos

```
backend/src/
â”œâ”€â”€ main.rs                      # Entry point, inicializa mÃ³dulos
â”œâ”€â”€ config/                      # ConfiguraciÃ³n global
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ database.rs
â”‚   â”œâ”€â”€ redis.rs
â”‚   â””â”€â”€ app.rs
â”œâ”€â”€ middleware/                  # Middleware compartido
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ auth.rs
â”‚   â”œâ”€â”€ logging.rs
â”‚   â””â”€â”€ cors.rs
â”œâ”€â”€ shared/                      # CÃ³digo compartido entre mÃ³dulos
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ models.rs               # Modelos comunes
â”‚   â”œâ”€â”€ errors.rs               # Manejo de errores
â”‚   â”œâ”€â”€ utils.rs                # Utilidades
â”‚   â””â”€â”€ database/
â”‚       â”œâ”€â”€ mod.rs
â”‚       â””â”€â”€ pool.rs
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ catalogo/               # ðŸŸ¢ MÃ“DULO 1
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ handlers.rs
â”‚   â”‚   â”œâ”€â”€ services.rs
â”‚   â”‚   â”œâ”€â”€ repository.rs
â”‚   â”‚   â”œâ”€â”€ models.rs
â”‚   â”‚   â””â”€â”€ routes.rs
â”‚   â”œâ”€â”€ compras/                # ðŸ”µ MÃ“DULO 2
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ handlers.rs
â”‚   â”‚   â”œâ”€â”€ services.rs
â”‚   â”‚   â”œâ”€â”€ repository.rs
â”‚   â”‚   â”œâ”€â”€ models.rs
â”‚   â”‚   â””â”€â”€ routes.rs
â”‚   â””â”€â”€ gestion/                # ðŸŸ¡ MÃ“DULO 3
â”‚       â”œâ”€â”€ mod.rs
â”‚       â”œâ”€â”€ handlers.rs
â”‚       â”œâ”€â”€ services.rs
â”‚       â”œâ”€â”€ repository.rs
â”‚       â”œâ”€â”€ models.rs
â”‚       â””â”€â”€ routes.rs
â””â”€â”€ integrations/               # Integraciones externas
    â”œâ”€â”€ mod.rs
    â”œâ”€â”€ stripe.rs
    â”œâ”€â”€ email.rs
    â””â”€â”€ storage.rs

frontend/src/
â”œâ”€â”€ routes/                     # Rutas de SvelteKit
â”‚   â”œâ”€â”€ +layout.svelte
â”‚   â”œâ”€â”€ +page.svelte           # Home
â”‚   â”œâ”€â”€ productos/             # ðŸŸ¢ MÃ“DULO 1
â”‚   â”‚   â”œâ”€â”€ +page.svelte
â”‚   â”‚   â””â”€â”€ [slug]/
â”‚   â”‚       â””â”€â”€ +page.svelte
â”‚   â”œâ”€â”€ carrito/               # ðŸ”µ MÃ“DULO 2
â”‚   â”‚   â””â”€â”€ +page.svelte
â”‚   â””â”€â”€ cuenta/                # ðŸ”µ MÃ“DULO 2
â”‚       â””â”€â”€ pedidos/
â”‚           â””â”€â”€ +page.svelte
â””â”€â”€ lib/
    â”œâ”€â”€ components/
    â”‚   â”œâ”€â”€ catalogo/          # ðŸŸ¢ Componentes MÃ³dulo 1
    â”‚   â”œâ”€â”€ compras/           # ðŸ”µ Componentes MÃ³dulo 2
    â”‚   â””â”€â”€ shared/            # Componentes compartidos
    â”œâ”€â”€ stores/
    â”‚   â”œâ”€â”€ catalogo.js        # ðŸŸ¢ Store MÃ³dulo 1
    â”‚   â”œâ”€â”€ carrito.js         # ðŸ”µ Store MÃ³dulo 2
    â”‚   â””â”€â”€ auth.js            # Store compartido
    â””â”€â”€ api/
        â”œâ”€â”€ catalogo.js        # ðŸŸ¢ API Client MÃ³dulo 1
        â””â”€â”€ compras.js         # ðŸ”µ API Client MÃ³dulo 2

admin/src/
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ admin/
â”‚   â”‚   â”œâ”€â”€ productos/         # ðŸŸ¢ MÃ“DULO 1
â”‚   â”‚   â”œâ”€â”€ inventario/        # ðŸŸ¡ MÃ“DULO 3
â”‚   â”‚   â”œâ”€â”€ pedidos/           # ðŸ”µ MÃ“DULO 2
â”‚   â”‚   â””â”€â”€ reportes/          # ðŸŸ¡ MÃ“DULO 3
```

---

### AsignaciÃ³n de MÃ³dulos

| **Desarrollador** | **MÃ³dulo** | **Responsabilidades** |
|-------------------|------------|-----------------------|
| **Persona 1** | ðŸŸ¢ CatÃ¡logo y BÃºsqueda | â€¢ Listado de productos<br/>â€¢ BÃºsqueda y filtros<br/>â€¢ Detalle de producto<br/>â€¢ Valoraciones<br/>â€¢ Home page |
| **Persona 2** | ðŸ”µ Compras y Pagos | â€¢ Carrito de compras<br/>â€¢ Checkout<br/>â€¢ Pagos (Stripe)<br/>â€¢ GestiÃ³n de usuarios<br/>â€¢ Pedidos |
| **Persona 3** | ðŸŸ¡ GestiÃ³n y Admin | â€¢ Panel administrativo<br/>â€¢ Inventario<br/>â€¢ Reportes<br/>â€¢ Ã“rdenes de compra<br/>â€¢ AuditorÃ­a |

---

## Arquitectura Modular

### PatrÃ³n de Capas por MÃ³dulo

Cada mÃ³dulo sigue el patrÃ³n **3-Layer Architecture**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         HANDLERS (HTTP)             â”‚  â† Capa de PresentaciÃ³n
â”‚  â€¢ Recibe requests HTTP             â”‚
â”‚  â€¢ Valida input                     â”‚
â”‚  â€¢ Retorna responses                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         SERVICES (LÃ³gica)           â”‚  â† Capa de Negocio
â”‚  â€¢ LÃ³gica de negocio                â”‚
â”‚  â€¢ OrquestaciÃ³n                     â”‚
â”‚  â€¢ Llamadas a APIs externas         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       REPOSITORY (Datos)            â”‚  â† Capa de Datos
â”‚  â€¢ Queries a BD                     â”‚
â”‚  â€¢ CRUD operations                  â”‚
â”‚  â€¢ Cache management                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Ejemplo de Flujo de Request

```rust
// 1. HANDLER - handlers.rs
pub async fn get_producto(
    Path(id): Path(i32>,
    State(app_state): State<AppState>
) -> Result<Json<ProductoResponse>, ApiError> {
    // Validar input
    if id <= 0 {
        return Err(ApiError::BadRequest("ID invÃ¡lido".to_string()));
    }
    
    // Llamar al service
    let producto = services::get_producto_by_id(&app_state.db_pool, id).await?;
    
    // Retornar response
    Ok(Json(producto))
}

// 2. SERVICE - services.rs
pub async fn get_producto_by_id(
    pool: &PgPool,
    id: i32
) -> Result<ProductoResponse, ServiceError> {
    // LÃ³gica de negocio
    // Intentar obtener de cache
    if let Some(cached) = get_from_cache(id).await {
        return Ok(cached);
    }
    
    // Obtener de BD via repository
    let producto = repository::find_producto_by_id(pool, id).await?;
    
    // Procesar y transformar
    let response = ProductoResponse::from(producto);
    
    // Guardar en cache
    save_to_cache(id, &response).await;
    
    Ok(response)
}

// 3. REPOSITORY - repository.rs
pub async fn find_producto_by_id(
    pool: &PgPool,
    id: i32
) -> Result<Producto, RepositoryError> {
    let producto = sqlx::query_as!(
        Producto,
        r#"
        SELECT * FROM producto_detalle
        WHERE id_producto_detalle = $1 AND estado = 'Activo'
        "#,
        id
    )
    .fetch_one(pool)
    .await?;
    
    Ok(producto)
}
```

---

## MÃ³dulo 1: CatÃ¡logo y BÃºsqueda

### Responsabilidades

**Backend:**
- âœ… API de listado de productos con paginaciÃ³n
- âœ… API de bÃºsqueda con filtros avanzados
- âœ… API de detalle de producto
- âœ… API de valoraciones (CRUD)
- âœ… API de categorÃ­as y familias
- âœ… Sistema de cache para productos

**Frontend:**
- âœ… Home page con banners y productos destacados
- âœ… CatÃ¡logo con filtros (sidebar)
- âœ… BÃºsqueda global
- âœ… PÃ¡gina de detalle de producto
- âœ… Sistema de valoraciones (lectura y escritura)
- âœ… Comparador de productos (opcional)

---

### Estructura de Archivos

```
backend/src/modules/catalogo/
â”œâ”€â”€ mod.rs                    # Exporta submÃ³dulos
â”œâ”€â”€ routes.rs                 # DefiniciÃ³n de rutas
â”œâ”€â”€ handlers.rs               # HTTP handlers
â”œâ”€â”€ services.rs               # LÃ³gica de negocio
â”œâ”€â”€ repository.rs             # Queries a BD
â”œâ”€â”€ models.rs                 # Structs y DTOs
â””â”€â”€ cache.rs                  # Cache management

frontend/src/lib/components/catalogo/
â”œâ”€â”€ ProductCard.svelte        # Card de producto
â”œâ”€â”€ ProductGrid.svelte        # Grid de productos
â”œâ”€â”€ FilterSidebar.svelte      # Filtros laterales
â”œâ”€â”€ SearchBar.svelte          # Barra de bÃºsqueda
â”œâ”€â”€ ProductDetail.svelte      # Detalle completo
â”œâ”€â”€ ReviewList.svelte         # Lista de reseÃ±as
â”œâ”€â”€ ReviewForm.svelte         # Formulario de reseÃ±a
â””â”€â”€ StarRating.svelte         # Componente de estrellas
```

---

### Endpoints de API

```rust
// routes.rs
pub fn routes() -> Router<AppState> {
    Router::new()
        // Productos
        .route("/api/productos", get(handlers::list_productos))
        .route("/api/productos/:id", get(handlers::get_producto))
        .route("/api/productos/slug/:slug", get(handlers::get_producto_by_slug))
        
        // BÃºsqueda
        .route("/api/busqueda", get(handlers::search_productos))
        
        // CategorÃ­as
        .route("/api/categorias", get(handlers::list_categorias))
        .route("/api/categorias/:id/productos", get(handlers::productos_by_categoria))
        
        // Familias
        .route("/api/familias", get(handlers::list_familias))
        
        // Marcas
        .route("/api/marcas", get(handlers::list_marcas))
        
        // Valoraciones
        .route("/api/productos/:id/valoraciones", get(handlers::get_valoraciones))
        .route("/api/valoraciones", post(handlers::create_valoracion).layer(auth_middleware()))
        .route("/api/valoraciones/:id", patch(handlers::update_valoracion).layer(auth_middleware()))
        
        // Home
        .route("/api/home/destacados", get(handlers::productos_destacados))
        .route("/api/home/ofertas", get(handlers::productos_oferta))
        .route("/api/home/nuevos", get(handlers::productos_nuevos))
        .route("/api/home/banners", get(handlers::get_banners))
}
```

---

### Ejemplo de ImplementaciÃ³n - Backend

```rust
// models.rs
#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct ProductoDetalle {
    pub id_producto_detalle: i32,
    pub nombre: String,
    pub slug: String,
    pub precio_venta: Decimal,
    pub imagen_principal: Option<String>,
    pub es_destacado: bool,
    pub es_nuevo: bool,
    pub es_oferta: bool,
    // ... mÃ¡s campos
}

#[derive(Debug, Deserialize)]
pub struct ProductoQuery {
    pub page: Option<i32>,
    pub limit: Option<i32>,
    pub categoria: Option<i32>,
    pub marca: Option<i32>,
    pub precio_min: Option<Decimal>,
    pub precio_max: Option<Decimal>,
    pub ordenar: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct ProductoListResponse {
    pub productos: Vec<ProductoDetalle>,
    pub total: i64,
    pub page: i32,
    pub total_pages: i32,
}

// repository.rs
pub async fn list_productos(
    pool: &PgPool,
    query: &ProductoQuery
) -> Result<(Vec<ProductoDetalle>, i64), sqlx::Error> {
    let page = query.page.unwrap_or(1);
    let limit = query.limit.unwrap_or(20);
    let offset = (page - 1) * limit;
    
    let mut sql = String::from(
        "SELECT * FROM producto_detalle WHERE estado = 'Activo'"
    );
    
    // Aplicar filtros
    if let Some(cat) = query.categoria {
        sql.push_str(&format!(" AND id_categoria = {}", cat));
    }
    
    if let Some(marca) = query.marca {
        sql.push_str(&format!(" AND id_marca = {}", marca));
    }
    
    if let Some(min) = query.precio_min {
        sql.push_str(&format!(" AND precio_venta >= {}", min));
    }
    
    if let Some(max) = query.precio_max {
        sql.push_str(&format!(" AND precio_venta <= {}", max));
    }
    
    // Ordenar
    match query.ordenar.as_deref() {
        Some("precio_asc") => sql.push_str(" ORDER BY precio_venta ASC"),
        Some("precio_desc") => sql.push_str(" ORDER BY precio_venta DESC"),
        Some("nuevos") => sql.push_str(" ORDER BY created_at DESC"),
        _ => sql.push_str(" ORDER BY id_producto_detalle DESC"),
    }
    
    sql.push_str(&format!(" LIMIT {} OFFSET {}", limit, offset));
    
    let productos = sqlx::query_as::<_, ProductoDetalle>(&sql)
        .fetch_all(pool)
        .await?;
    
    // Contar total
    let total: (i64,) = sqlx::query_as("SELECT COUNT(*) FROM producto_detalle WHERE estado = 'Activo'")
        .fetch_one(pool)
        .await?;
    
    Ok((productos, total.0))
}

// services.rs
pub async fn get_productos_list(
    pool: &PgPool,
    query: ProductoQuery
) -> Result<ProductoListResponse, ServiceError> {
    let (productos, total) = repository::list_productos(pool, &query).await?;
    
    let page = query.page.unwrap_or(1);
    let limit = query.limit.unwrap_or(20);
    let total_pages = (total as f64 / limit as f64).ceil() as i32;
    
    Ok(ProductoListResponse {
        productos,
        total,
        page,
        total_pages,
    })
}

// handlers.rs
pub async fn list_productos(
    Query(query): Query<ProductoQuery>,
    State(app_state): State<AppState>,
) -> Result<Json<ProductoListResponse>, ApiError> {
    let response = services::get_productos_list(&app_state.db_pool, query).await?;
    Ok(Json(response))
}
```

#### Frontend

```html
<!-- routes/productos/+page.svelte -->
<script>
  import { onMount } from 'svelte';
  import ProductGrid from '$lib/components/catalogo/ProductGrid.svelte';
  import FilterSidebar from '$lib/components/catalogo/FilterSidebar.svelte';
  import { getProductos } from '$lib/api/catalogo';
  
  let productos = [];
  let loading = true;
  let filtros = {
    page: 1,
    limit: 20,
    categoria: null,
    marca: null,
    precio_min: null,
    precio_max: null,
    ordenar: 'relevancia'
  };
  let totalPages = 1;
  
  async function cargarProductos() {
    loading = true;
    try {
      const response = await getProductos(filtros);
      productos = response.productos;
      totalPages = response.total_pages;
    } catch (error) {
      console.error('Error cargando productos:', error);
    } finally {
      loading = false;
    }
  }
  
  function aplicarFiltros(nuevosFiltros) {
    filtros = { ...filtros, ...nuevosFiltros, page: 1 };
    cargarProductos();
  }
  
  onMount(() => {
    cargarProductos();
  });
</script>

<div class="container mx-auto py-8">
  <div class="grid grid-cols-12 gap-6">
    <!-- Sidebar de filtros -->
    <div class="col-span-3">
      <FilterSidebar on:filtrar={e => aplicarFiltros(e.detail)} />
    </div>
    
    <!-- Grid de productos -->
    <div class="col-span-9">
      {#if loading}
        <div>Cargando...</div>
      {:else}
        <ProductGrid {productos} />
        
        <!-- PaginaciÃ³n -->
        <div class="mt-8 flex justify-center">
          {#each Array(totalPages) as _, i}
            <button
              class="mx-1 px-4 py-2 {filtros.page === i + 1 ? 'bg-blue-500 text-white' : 'bg-gray-200'}"
              on:click={() => { filtros.page = i + 1; cargarProductos(); }}
            >
              {i + 1}
            </button>
          {/each}
        </div>
      {/if}
    </div>
  </div>
</div>
```

---